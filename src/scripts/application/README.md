# Example 1. Star Wars application.

This example should give an answer to a number of chalanges that could face a developer,
while working on React application.

### If `Data Sort` is requested

Any type of sorting could be applied to a set of data (any amount of data).
If you are using reducer, then input amount should equal to an output amount of data.

### If `Data filter` is requested

This operation requires to reduce amount of visible data to a specific one by provided `id`.
In this case we can't rely on visible data as user interface would be broken
(user would see different amount of data per page or no data at all).
So, filter type should be a part of a REST API request.

One could argue to run filter on saved data (save response to a localStorage or to a memory),
but we can't be sure how much data user requested already or what technical limitations for one's laptop.

Filter change could be applied through `componentDidUpdate` function.

    componentDidUpdate(prevProps) {
      const { filter } = this.props;

      if (filter !== prevProps.filter) {
        // fetch new batch of data
      }
    }

## Application logic

The initial point of App is `index.js` that simply connects DOM with Application itself.

    import React from 'react';
    import ReactDOM from 'react-dom';
    import Application from 'src/application/app.jsx';

    ReactDOM.render(
      <Application />,
      document.getElementById('application')
    );

The next important peace is the App core itself `src/application/app.jsx`.
It should connect main Component, Store and Saga together.

    import React from 'react';
    import { Provider } from 'react-redux';

    import store from '../config/store';
    import VehiclesApp from './vehicles/container';

    const App = function App(props) {
      return (
        <Provider store={store}>
          <VehiclesApp {...props} />
        </Provider>
      );
    };

    export default App;

As Application utilises Redux store as a one source of truth,
that why each functional peace of App is composed as Container/Components pair.
Container connects Component with Store. Component only knows how to displays data and initiates actions.

**Container**

    // It should connect React component with Redux store
    //
    // Purpose: How things work (data fetching, state updates)
    // Aware of Redux: Yes
    // To read data: Subscribe to Redux state
    // To change data: Dispatch Redux actions
    // Are written: Usually generated by React Redux
    // --------------------------------

    import { connect } from 'react-redux';

    import Component from './component.jsx';

    /**
     * Expose state of store section to it's Component
     *
     * @param   {object} state Application store state
     *
     * @returns {object}       Component store section current state
     */
    const mapStateToProps = state => ({
      vehicles: state.vehicles,
    });

    export default connect(
      mapStateToProps,
    )(Component);

**Component**

    // Setup UI presentation and rules how to display data
    //
    // Purpose: How things look (markup, styles)
    // Aware of Redux: No
    // To read data: Read data from props
    // To change data: Invoke callbacks from props
    // Are written: By hand
    // --------------------------------

    import React from 'react';
    import PropTypes from 'prop-types';

    import List from './list/container';

    class VehiclesComponent extends React.Component {
      constructor(props) {
        super(props);

        // React autobinding pattern
        this.onSubmit = this.onSubmit.bind(this);
      }

      componentDidMount() {
        const { fetchVehicles } = this.props;

        // Populate list with data on page load;
        // dispatch an action to Saga
        fetchVehicles();
      }

      onSubmit() {
        // do something
      }

      render() {
        return (
          <article className="vehicles-wrapper">
            <h1>Star Wars vehicles dictionary</h1>
            <List {...this.props} />

            <button type="button" onClick={this.onSubmit}>
              Submit
            </button>
          </article>
        );
      }
    }

    VehiclesComponent.propTypes = {
      fetchVehicles: PropTypes.func.isRequired,
    };

    export default VehiclesComponent;

Store itself should compose together list of actions, data reducers and Saga middleware.

    import { createStore, applyMiddleware } from 'redux';
    import createSagaMiddleware from 'redux-saga';

    import rootReducer from '../store/reducers/core';
    import rootSaga from './saga';

    const sagaMiddleware = createSagaMiddleware();
    const store = createStore(
      rootReducer,
      applyMiddleware(sagaMiddleware),
    );

    sagaMiddleware.run(rootSaga);

    export default store;


Actions is a pure functions, that return an object with required `type` property.
Types should typically be defined as a string constant.
If you're interested, check out [Flux Standard Action](https://github.com/redux-utilities/flux-standard-action)
for recommendations on how actions could be constructed.

    import CONSTANTS from '../../config/constants';

    export function fetchData(config = {}) {
      return {
        type: CONSTANTS.FETCH_DATA,
        page: config.page || 1,
        pageCount: config.pageCount || 10,
      };
    }

    export function sortData(direction) {
      return {
        type: CONSTANTS[`SORT_${direction.toUpperCase()}`],
      };
    }

Reducer is a function that gets state and an action as parameters,
and returns a new state by combining old and new one. Each reduce could be as a separate file,
but they have to be combined together as one rootReducer.

combineReducers (Redux) function should get an object of reducers as `{ <sourceName>: fn }`.
Where `<sourceName>` will be used later by Container or Component to retrieve the latest state of the Application.

**Root reducer**

    import { combineReducers } from 'redux';

    import CONSTANTS from '../../config/constants';
    import vehicleReducer from './vehicles';

    const initialState = {
      vehicles: [],
    };

    const vehicles = (state = initialState.vehicles, action) => {
      const handlers = {
        [CONSTANTS.FETCH_SUCCESS]: vehicleReducer,
      };

      return handlers[action.type]
        ? handlers[action.type](state, action)
        : state;
    };

    const rootReducer = combineReducers({
      vehicles,
    });

    export default rootReducer;


**vehicleReducer**

    import CONSTANTS from '../../config/constants';

    export default function vehicleReducer(state, action) {
      switch (action.type) {
        case CONSTANTS.FETCH_SUCCESS:
          return [
            ...state,
            ...action.vehicles,
          ];

        default:
          return state;
      }
    }

Saga middleware contains the logic on how to connect async requests with Store state.

    import {
      takeLatest,
      call,
      put,
      all,
    } from 'redux-saga/effects';

    import Api from '../services/api';
    import CONSTANTS from './constants';

    /**
     * Retrieves data by provided URL and dispatches an event with response payload
     *
     * @yields {object} server response with a list of results property
     */
    function* fetchVehicles() {
      try {
        const response = yield call(
          Api.fetch,
          'https://swapi.co/api/vehicles/',
        );

        yield put({
          type: CONSTANTS.FETCH_SUCCESS,
          vehicles: response.results,
        });
      } catch (error) {
        console.log('fetchVehicles error', error);
      }
    }

    /**
     * Set a watcher for a fetch data event
     * and cancels any previous similar requests
     *
     * @yields {object} action
     */
    function* watchFetchVehicles() {
      yield takeLatest(CONSTANTS.FETCH_DATA, fetchVehicles);
    }

    export default function* rootSaga() {
      yield all([
        watchFetchVehicles(),
      ]);
    }

Do not forget to add a separate file for action types and any other constants.

    const actionsType = {
      FETCH_DATA: 'FETCH_DATA',
      FETCH_SUCCESS: 'FETCH_SUCCESS',
      SORT_ASC: 'SORT_ASC',
      SORT_DESC: 'SORT_DESC',
    };

    export default actionsType;